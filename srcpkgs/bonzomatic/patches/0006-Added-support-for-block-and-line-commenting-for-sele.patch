From 2ac2dfcfc05eea8c4416ee1e2cc9f003b0c131e6 Mon Sep 17 00:00:00 2001
From: Nightfox <cameronscottarmstrong@gmail.com>
Date: Sat, 8 Jun 2019 20:29:42 +0800
Subject: [PATCH 06/21] Added support for block and line commenting for
 selected text

---
 .gitignore                     |  1 +
 README.md                      |  4 ++-
 src/ShaderEditor.cpp           | 65 ++++++++++++++++++++++++++++------
 src/ShaderEditor.h             | 12 ++++++-
 src/main.cpp                   | 14 +++++++-
 src/platform_glfw/Renderer.cpp |  1 +
 6 files changed, 84 insertions(+), 13 deletions(-)

diff --git .gitignore .gitignore
index 5efe05f..4d3bdc8 100644
--- .gitignore
+++ .gitignore
@@ -5,3 +5,4 @@ build
 .vs
 .DS_Store
 cmake-build*
+.vscode
diff --git README.md README.md
index 26d2171..0c48dfd 100644
--- README.md
+++ README.md
@@ -15,7 +15,9 @@ The tool was originally conceived and implemented after the Revision 2014 demosc
 - F5 or Ctrl-R: recompile shader
 - F11 or Ctrl/Cmd-f: hide shader overlay
 - Alt-F4 or Shift+Escape: exbobolate your planet
-- Ctrl/Cmd + /: comment or uncomment the selected lines of code
+- Ctrl/Cmd + / or Ctrl/Cmd + K: comment or uncomment the selected lines of code
+- /: when text is selected, comment or uncomment every selected line
+- Shift + 8: when text is selected, perform a block comment between selected code 
 
 ## Requirements
 On Windows, both DirectX 9 and 11 are supported.
diff --git src/ShaderEditor.cpp src/ShaderEditor.cpp
index 8ea5595..fa7ea2e 100644
--- src/ShaderEditor.cpp
+++ src/ShaderEditor.cpp
@@ -414,28 +414,73 @@ void ShaderEditor::FineTickerCancel( TickReason )
 
 }
 
-void ShaderEditor::CommentSelection()
+// Comment or uncomment the selected text in the code editor.
+// Returns true if an action was performed
+bool ShaderEditor::CommentSelection(CommentType commentType)
 {
   int selectionStartPosition = WndProc(SCI_GETSELECTIONSTART, 0, 0);
   int selectionEndPosition = WndProc(SCI_GETSELECTIONEND, 0, 0);
   int firstSelectedLine = WndProc(SCI_LINEFROMPOSITION, selectionStartPosition, 0);
   int lastSelectedLine = WndProc(SCI_LINEFROMPOSITION, selectionEndPosition, 0);
 
-  for (int line = firstSelectedLine; line <= lastSelectedLine; line++) {
-    int lineStartPosition = WndProc(SCI_POSITIONFROMLINE, line, 0);
-    char firstCharacterOFLine = WndProc(SCI_GETCHARAT, lineStartPosition, 0);
-    if (firstCharacterOFLine == '/') {
-        // We are uncommenting this line
+  CommentMode commentMode;
+
+  switch (commentType) {
+  case ctLinesSelectedOnly:
+    // If no lines are selected then do nothing
+    if (selectionStartPosition == selectionEndPosition) return false;
+  case ctLinesAll:
+    // Perform line (un)commenting "//"
+    for (int line = firstSelectedLine; line <= lastSelectedLine; line++) {
+      int lineStartPosition = WndProc(SCI_POSITIONFROMLINE, line, 0);
+      char firstCharacterOfLine = WndProc(SCI_GETCHARAT, lineStartPosition, 0);
+      commentMode = firstCharacterOfLine == '/' ? cmUncomment : cmComment;
+      if (commentMode == cmComment) {
+        WndProc(SCI_INSERTTEXT, lineStartPosition, reinterpret_cast<sptr_t>("//"));
+      }
+      else {
         WndProc(SCI_DELETERANGE, lineStartPosition, 2);
+      }
     }
-    else {
-        // We are commenting this line
-        WndProc(SCI_INSERTTEXT, lineStartPosition, reinterpret_cast<sptr_t>("//"));
+    return true;
+  case ctBlock:
+    // If no lines are selected then do nothing
+    if (selectionStartPosition == selectionEndPosition) return false;
+
+    // Perform block (un)commenting between selection start and end of selected text (*/ /*)
+    commentMode = cmComment;
+    int beginningSelectionOffset;
+    int endSelectionOffset;
+    for (beginningSelectionOffset = -2; beginningSelectionOffset <= 0; beginningSelectionOffset++) {
+      char characterAtOffset = WndProc(SCI_GETCHARAT, selectionStartPosition + beginningSelectionOffset, 0);
+      char secondCharacterFromOffset = WndProc(SCI_GETCHARAT, selectionStartPosition + beginningSelectionOffset + 1, 0);
+      if (characterAtOffset == '/' && secondCharacterFromOffset == '*') {
+        // We have found a "/*" at the beginning of selection. Looks like we are going to uncomment a block but let's check for a "*/" at the end to make sure.
+        for (endSelectionOffset = -2; endSelectionOffset <= 0; endSelectionOffset++) {
+          characterAtOffset = WndProc(SCI_GETCHARAT, selectionEndPosition + endSelectionOffset, 0);
+          secondCharacterFromOffset = WndProc(SCI_GETCHARAT, selectionEndPosition + endSelectionOffset + 1, 0);
+          if (characterAtOffset == '*' && secondCharacterFromOffset == '/') {
+            commentMode = cmUncomment;
+            break;
+          }
+        }
+        break;
+      }
     }
+
+    if (commentMode == cmComment) {
+      char characterAtOffset = WndProc(SCI_GETCHARAT, selectionStartPosition, 0);
+      WndProc(SCI_INSERTTEXT, selectionStartPosition, reinterpret_cast<sptr_t>("/*"));
+      WndProc(SCI_INSERTTEXT, selectionEndPosition + 2, reinterpret_cast<sptr_t>("*/"));
+    }
+    else if (commentMode == cmUncomment) {
+      WndProc(SCI_DELETERANGE, selectionStartPosition + beginningSelectionOffset, 2);
+      WndProc(SCI_DELETERANGE, selectionEndPosition + endSelectionOffset - 2, 2);
+    }
+    return true;
   }
 }
 
-
 /////////////////////////////////////////////////////////////////////////////////////////////
 // Indentation handling
 
diff --git src/ShaderEditor.h src/ShaderEditor.h
index 719d3f9..f2d9206 100644
--- src/ShaderEditor.h
+++ src/ShaderEditor.h
@@ -67,6 +67,11 @@ struct SHADEREDITOR_THEME {
   unsigned int charBackground   = 0xC0000000;
   bool bUseCharBackground = false;
 };
+enum CommentType {
+  ctLinesSelectedOnly,
+  ctLinesAll,
+  ctBlock
+};
 
 struct SHADEREDITOR_OPTIONS {
   std::string sFontPath;
@@ -137,7 +142,7 @@ public:
 
   void SetReadOnly( bool );
   Scintilla::Font * GetTextFont();
-  void CommentSelection();
+  bool CommentSelection(CommentType);
     
 private:
   enum IndentationStatus {
@@ -146,6 +151,11 @@ private:
     isBlockEnd,    // indentation end indicator such as "}" or VB "end"
     isKeyWordStart // Keywords that cause indentation
   };
+
+  enum CommentMode {
+    cmComment,
+    cmUncomment
+  };
   
   int GetLineLength(int line);
   int GetCurrentLineNumber();
diff --git src/main.cpp src/main.cpp
index 29f3969..af64e10 100644
--- src/main.cpp
+++ src/main.cpp
@@ -444,9 +444,21 @@ int main(int argc, const char *argv[])
           mDebugOutput.SetText( szError );
         }
       }
+      else if (!Renderer::keyEventBuffer[i].ctrl && Renderer::keyEventBuffer[i].scanCode == '/')
+      {
+        bool clearKeyEventBuffer = mShaderEditor.CommentSelection(ctLinesSelectedOnly);
+        if (clearKeyEventBuffer)
+          Renderer::keyEventBufferCount = 0;
+      }
+      else if (Renderer::keyEventBuffer[i].shift && Renderer::keyEventBuffer[i].scanCode == '*')
+      {
+        bool clearKeyEventBuffer = mShaderEditor.CommentSelection(ctBlock);
+        if (clearKeyEventBuffer)
+          Renderer::keyEventBufferCount = 0;
+      }
       else if (Renderer::keyEventBuffer[i].ctrl && (Renderer::keyEventBuffer[i].scanCode == '/' || Renderer::keyEventBuffer[i].scanCode == 'k')) // Ctrl/Cmd Slash (/) or Ctrl/Cmd-k
       {
-        mShaderEditor.CommentSelection();
+        mShaderEditor.CommentSelection(ctLinesAll);
       }
       else if (Renderer::keyEventBuffer[i].scanCode == 292 || (Renderer::keyEventBuffer[i].ctrl && Renderer::keyEventBuffer[i].scanCode == 'f')) // F11 or Ctrl/Cmd-f  
       {
diff --git src/platform_glfw/Renderer.cpp src/platform_glfw/Renderer.cpp
index d8fb046..83031c8 100644
--- src/platform_glfw/Renderer.cpp
+++ src/platform_glfw/Renderer.cpp
@@ -496,6 +496,7 @@ namespace Renderer
 //           case GLFW_KEY_RSUPER:       sciKey = SCK_RWIN;      break;
         case GLFW_KEY_MENU:         sciKey = SCK_MENU;      break;
         case GLFW_KEY_SLASH:        sciKey = '/';           break;
+        case GLFW_KEY_8:            sciKey = '*';           break;
 //           case GLFW_KEY_ASTERISK:     sciKey = '`';           break;
 //           case GLFW_KEY_LEFTBRACKET:  sciKey = '[';           break;
 //           case GLFW_KEY_BACKSLASH:    sciKey = '\\';          break;
-- 
2.25.0

