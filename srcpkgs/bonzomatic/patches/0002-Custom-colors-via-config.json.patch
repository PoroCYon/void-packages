From a5e3229ef9490cc2114f802f5eb9b793340126b1 Mon Sep 17 00:00:00 2001
From: mathieu _alkama_ m <code@alkama.com>
Date: Wed, 6 Nov 2019 01:40:17 +0100
Subject: [PATCH 02/21] Custom colors via config.json

Also handles:
- background color override for characters (it will only appear behind characters)
- selection background color override
---
 CMakeLists.txt                        |  2 ++
 README.md                             | 13 ++++++++
 external/scintilla/src/EditView.cxx   |  4 +++
 external/scintilla/src/MarginView.cxx |  4 +++
 src/ShaderEditor.cpp                  | 48 +++++++++++++++++++++------
 src/ShaderEditor.h                    | 16 +++++++++
 src/main.cpp                          | 42 +++++++++++++++++++++++
 7 files changed, 118 insertions(+), 11 deletions(-)

diff --git CMakeLists.txt CMakeLists.txt
index 95b19ae..78debc9 100644
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -468,6 +468,8 @@ if (APPLE)
   if (BONZOMATIC_TOUCHBAR)
     target_compile_definitions(${BZC_EXE_NAME} PUBLIC -DBONZOMATIC_ENABLE_TOUCHBAR)
   endif ()
+elseif (UNIX AND (NOT APPLE))
+  target_compile_options(${BZC_EXE_NAME} PUBLIC -std=c++11)
 elseif (WIN32)
   if (BONZOMATIC_NDI)
     target_compile_definitions(${BZC_EXE_NAME} PUBLIC -DBONZOMATIC_ENABLE_NDI)
diff --git README.md README.md
index e1f52a4..f3c763a 100644
--- README.md
+++ README.md
@@ -71,6 +71,19 @@ The file can have the following contents: (all fields are optional)
     "frameRate": 60.0, // frames per second
     "progressive": true, // progressive or interleaved?
   },
+  // this section is if you want to customise colors to your liking
+  "theme":{
+    "text": "FFFFFF", // color format is "RRGGBB" or "AARRGGBB" in hexadecimal
+    "comment": "00FF00",
+    "number": "FF8000",
+    "op": "FFCC00",
+    "keyword": "FF6600",
+    "type": "00FFFF",
+    "builtin": "44FF88",
+    "preprocessor": "C0C0C0",
+    "selection": "C06699CC", // background color when selecting text
+    "charBackground":   "C0000000", // if set, this value will be used (instead of gui opacity) behind characters
+  },
   "postExitCmd":"copy_to_dropbox.bat" // this command gets ran when you quit Bonzomatic, and the shader filename gets passed to it as first parameter. Use this to take regular backups.
 }
 ```
diff --git external/scintilla/src/EditView.cxx external/scintilla/src/EditView.cxx
index 4976d36..a976467 100644
--- external/scintilla/src/EditView.cxx
+++ external/scintilla/src/EditView.cxx
@@ -880,7 +880,11 @@ void EditView::DrawEOL(Surface *surface, const EditModel &model, const ViewStyle
 		if (background.isSet) {
 			surface->FillRectangle(rcSegment, background);
 		} else if (line < model.pdoc->LinesTotal() - 1) {
+			// Note(Bonzomatic): UGLY HACK TO REMOVE CHAR BACKGROUND ON END OF LINES
+			surface->FillRectangle(rcSegment, vsDraw.styles[STYLE_DEFAULT].back);
+			/*
 			surface->FillRectangle(rcSegment, vsDraw.styles[ll->styles[ll->numCharsInLine]].back);
+			*/
 		} else if (vsDraw.styles[ll->styles[ll->numCharsInLine]].eolFilled) {
 			surface->FillRectangle(rcSegment, vsDraw.styles[ll->styles[ll->numCharsInLine]].back);
 		} else {
diff --git external/scintilla/src/MarginView.cxx external/scintilla/src/MarginView.cxx
index b7ef485..6e0e43c 100644
--- external/scintilla/src/MarginView.cxx
+++ external/scintilla/src/MarginView.cxx
@@ -203,9 +203,13 @@ void MarginView::PaintMargin(Surface *surface, int topLine, PRectangle rc, PRect
 					// Required because of special way brush is created for selection margin
 					// Ensure patterns line up when scrolling with separate margin view
 					// by choosing correctly aligned variant.
+
+					// Note(Bonzomatic): UGLY HACK TO REMOVE THE DARK LEFT MARGIN BETWEEN LINE NUMBERS AND CODE
+					/*
 					bool invertPhase = static_cast<int>(ptOrigin.y) & 1;
 					surface->FillRectangle(rcSelMargin,
 						invertPhase ? *pixmapSelPattern : *pixmapSelPatternOffset1);
+					*/
 				} else {
 					ColourDesired colour;
 					switch (vs.ms[margin].style) {
diff --git src/ShaderEditor.cpp src/ShaderEditor.cpp
index 08d6cd5..ff33e47 100644
--- src/ShaderEditor.cpp
+++ src/ShaderEditor.cpp
@@ -108,7 +108,7 @@ void ShaderEditor::Initialise()
 
   WndProc(SCI_SETFOLDMARGINCOLOUR,   1, BACKGROUND( 0x1A1A1A ));
   WndProc(SCI_SETFOLDMARGINHICOLOUR, 1, BACKGROUND( 0x1A1A1A ));
-  WndProc(SCI_SETSELBACK,            1, BACKGROUND( 0xCC9966 ));
+  WndProc(SCI_SETSELBACK,            1, theme.selection);
 
   SetReadOnly(false);
 
@@ -134,17 +134,42 @@ void ShaderEditor::Initialise()
   lexState->SetWordList(0, shaderKeyword);
   lexState->SetWordList(1, shaderType);
   lexState->SetWordList(3, shaderBuiltin);
-
-  SetAStyle(SCE_C_DEFAULT,      0xFFFFFFFF, BACKGROUND( 0x000000 ), nFontSize, sFontFile.c_str() );
-  SetAStyle(SCE_C_WORD,         0xFF0066FF, BACKGROUND( 0x000000 ));
-  SetAStyle(SCE_C_WORD2,        0xFFFFFF00, BACKGROUND( 0x000000 ));
-  SetAStyle(SCE_C_GLOBALCLASS,  0xFF88FF44, BACKGROUND( 0x000000 ));  
-  SetAStyle(SCE_C_PREPROCESSOR, 0xFFC0C0C0, BACKGROUND( 0x000000 ));
-  SetAStyle(SCE_C_NUMBER,       0xFF0080FF, BACKGROUND( 0x000000 ));
-  SetAStyle(SCE_C_OPERATOR,     0xFF00CCFF, BACKGROUND( 0x000000 ));
-  SetAStyle(SCE_C_COMMENT,      0xFF00FF00, BACKGROUND( 0x000000 ));
-  SetAStyle(SCE_C_COMMENTLINE,  0xFF00FF00, BACKGROUND( 0x000000 ));
+  // Do not grey out code inside #if #else #endif (when set to 1 it causes problems with fully transparent background)
+  lexState->PropSet("lexer.cpp.track.preprocessor", "0");
+  // Colorize the content of the #defines (thx @blackle for finding it)
+  lexState->PropSet("styling.within.preprocessor", "1");
+
+  SetAStyle(SCE_C_DEFAULT, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000), nFontSize, sFontFile.c_str() );
+  SetAStyle(SCE_C_WORD, theme.keyword, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_WORD2, theme.type, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_GLOBALCLASS, theme.builtin, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_PREPROCESSOR, theme.preprocessor, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_NUMBER, theme.number, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_OPERATOR, theme.op, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_COMMENT, theme.comment, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_COMMENTLINE, theme.comment, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
   
+  // Misc chars to cover for standard text
+  SetAStyle(SCE_C_COMMENTDOC, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_STRING, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_CHARACTER, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_UUID, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_IDENTIFIER, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_STRINGEOL, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_VERBATIM, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_REGEX, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_COMMENTLINEDOC, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_COMMENTDOCKEYWORD, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_COMMENTDOCKEYWORDERROR, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_STRINGRAW, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_TRIPLEVERBATIM, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_HASHQUOTEDSTRING, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_PREPROCESSORCOMMENT, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_PREPROCESSORCOMMENTDOC, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_USERLITERAL, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_TASKMARKER, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+  SetAStyle(SCE_C_ESCAPESEQUENCE, theme.text, theme.bUseCharBackground ? theme.charBackground : BACKGROUND(0x000000));
+
   lexState->Colourise( 0, -1 );
 
   //WndProc( SCI_COLOURISE, 0, 0 );
@@ -161,6 +186,7 @@ void ShaderEditor::Initialise( SHADEREDITOR_OPTIONS &options )
   nTabSize = options.nTabSize;
   bVisibleWhitespace = options.bVisibleWhitespace;
   eAutoIndent = options.eAutoIndent;
+  theme = options.theme;
 
   Initialise();
   SetPosition( options.rect );
diff --git src/ShaderEditor.h src/ShaderEditor.h
index bde2536..91f79c0 100644
--- src/ShaderEditor.h
+++ src/ShaderEditor.h
@@ -54,6 +54,20 @@ enum AutoIndentationType {
   aitSmart
 };
 
+struct SHADEREDITOR_THEME {
+  unsigned int text             = 0xFFFFFFFF;
+  unsigned int comment          = 0xFF00FF00;
+  unsigned int number           = 0xFF0080FF;
+  unsigned int op               = 0xFF00CCFF;
+  unsigned int keyword          = 0xFF0066FF;
+  unsigned int type             = 0xFFFFFF00;
+  unsigned int builtin          = 0xFF88FF44;
+  unsigned int preprocessor     = 0xFFC0C0C0;
+  unsigned int selection        = 0xC0CC9966;
+  unsigned int charBackground   = 0xC0000000;
+  bool bUseCharBackground = false;
+};
+
 struct SHADEREDITOR_OPTIONS {
   std::string sFontPath;
   int nFontSize;
@@ -63,6 +77,7 @@ struct SHADEREDITOR_OPTIONS {
   int nTabSize;
   bool bVisibleWhitespace;
   AutoIndentationType eAutoIndent;
+  SHADEREDITOR_THEME theme;
 };
 
 class ShaderEditor : public Scintilla::Editor
@@ -79,6 +94,7 @@ class ShaderEditor : public Scintilla::Editor
   int nTabSize;
   bool bVisibleWhitespace;
   AutoIndentationType eAutoIndent;
+  SHADEREDITOR_THEME theme;
 
 public:
   ShaderEditor(Scintilla::Surface *surfaceWindow);
diff --git src/main.cpp src/main.cpp
index 69a729f..648f5d5 100644
--- src/main.cpp
+++ src/main.cpp
@@ -19,6 +19,22 @@
 #include "jsonxx.h"
 #include "Capture.h"
 
+unsigned int ParseColor(const std::string& color) {
+  if (color.size() < 6 || color.size() > 8) return 0xFFFFFFFF;
+  if (color.size() == 6)
+  {
+    std::string text = "0x" + color;
+    unsigned int v = std::stoul(text, 0, 16);
+    return (0xFF000000 | ((v & 0xFF0000) >> 16) | (v & 0x00FF00) | ((v & 0x0000FF) << 16));
+  }
+  else
+  {
+    std::string text = "0x" + color;
+    unsigned int v = std::stoul(text, 0, 16);
+    return ((v & 0xFF000000) | ((v & 0x00FF0000) >> 16) | (v & 0x0000FF00) | ((v & 0x000000FF) << 16));
+  }
+}
+
 void ReplaceTokens( std::string &sDefShader, const char * sTokenBegin, const char * sTokenName, const char * sTokenEnd, std::vector<std::string> &tokens )
 {
   if (sDefShader.find(sTokenBegin) != std::string::npos
@@ -232,6 +248,32 @@ int main(int argc, const char *argv[])
       if (options.get<jsonxx::Object>("gui").has<jsonxx::Number>("scrollYFactor"))
         fScrollYFactor = options.get<jsonxx::Object>("gui").get<jsonxx::Number>("scrollYFactor");
     }
+    if (options.has<jsonxx::Object>("theme"))
+    {
+      const auto& theme = options.get<jsonxx::Object>("theme");
+      if (theme.has<jsonxx::String>("text"))
+        editorOptions.theme.text = ParseColor(theme.get<jsonxx::String>("text"));
+      if (theme.has<jsonxx::String>("comment"))
+        editorOptions.theme.comment = ParseColor(theme.get<jsonxx::String>("comment"));
+      if (theme.has<jsonxx::String>("number"))
+        editorOptions.theme.number = ParseColor(theme.get<jsonxx::String>("number"));
+      if (theme.has<jsonxx::String>("op"))
+        editorOptions.theme.op = ParseColor(theme.get<jsonxx::String>("op"));
+      if (theme.has<jsonxx::String>("keyword"))
+        editorOptions.theme.keyword = ParseColor(theme.get<jsonxx::String>("keyword"));
+      if (theme.has<jsonxx::String>("type"))
+        editorOptions.theme.type = ParseColor(theme.get<jsonxx::String>("type"));
+      if (theme.has<jsonxx::String>("builtin"))
+        editorOptions.theme.builtin = ParseColor(theme.get<jsonxx::String>("builtin"));
+      if (theme.has<jsonxx::String>("preprocessor"))
+        editorOptions.theme.preprocessor = ParseColor(theme.get<jsonxx::String>("preprocessor"));
+      if (theme.has<jsonxx::String>("selection"))
+        editorOptions.theme.selection = ParseColor(theme.get<jsonxx::String>("selection"));
+      if (theme.has<jsonxx::String>("charBackground")) {
+        editorOptions.theme.bUseCharBackground = true;
+        editorOptions.theme.charBackground = ParseColor(theme.get<jsonxx::String>("charBackground"));
+      }
+    }
     if (options.has<jsonxx::Object>("midi"))
     {
       std::map<std::string, jsonxx::Value*> tex = options.get<jsonxx::Object>("midi").kv_map();
-- 
2.25.0

