commit 15f61ab7ee4936959708270152c936b25fd5a34f
Author: Timo J. Rinne <tri@iki.fi>
Date:   Fri Aug 17 11:35:48 2012 +0000

    Added tor-connect.

diff --git configure.in configure.in
index 02041c5..f5c9ee5 100644
--- configure.in 
+++ configure.in 
@@ -679,6 +679,7 @@ AC_CHECK_HEADERS(
         sys/prctl.h \
         sys/resource.h \
         sys/socket.h \
+        sys/select.h \
         sys/syslimits.h \
         sys/time.h \
         sys/types.h \
diff --git src/tools/Makefile.am src/tools/Makefile.am
index 35b0a41..05d5dc2 100644
--- src/tools/Makefile.am 
+++ src/tools/Makefile.am 
@@ -1,10 +1,14 @@
-bin_PROGRAMS = tor-resolve tor-gencert
+bin_PROGRAMS = tor-resolve tor-connect tor-gencert
 noinst_PROGRAMS =  tor-checkkey
 
 tor_resolve_SOURCES = tor-resolve.c
 tor_resolve_LDFLAGS =
 tor_resolve_LDADD = ../common/libor.a @TOR_LIB_MATH@ @TOR_LIB_WS32@
 
+tor_connect_SOURCES = tor-connect.c
+tor_connect_LDFLAGS =
+tor_connect_LDADD = ../common/libor.a @TOR_LIB_MATH@ @TOR_LIB_WS32@
+
 tor_gencert_SOURCES = tor-gencert.c
 tor_gencert_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@
 tor_gencert_LDADD = ../common/libor.a ../common/libor-crypto.a \
diff --git src/tools/tor-connect.c src/tools/tor-connect.c
new file mode 100644
index 0000000..eb393a1
--- /dev/null
+++ src/tools/tor-connect.c 
@@ -0,0 +1,640 @@
+/* Copyright (c) 2004-2006, Roger Dingledine, Nick Mathewson
+ * Copyright (c) 2007-2012, The Tor Project, Inc.
+ */
+/* See LICENSE for licensing information */
+
+#include "orconfig.h"
+
+#include "compat.h"
+#include "../common/util.h"
+#include "address.h"
+#include "../common/torlog.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <assert.h>
+
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h> /* Must be included before sys/stat.h for Ultrix */
+#endif
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+
+#ifdef MS_WINDOWS
+#if defined(_MSC_VER) && (_MSC_VER <= 1300)
+#include <winsock.h>
+#else
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#endif
+#endif
+
+#define RESPONSE_LEN_4 8
+#define log_sock_error(act, _s)                                         \
+  STMT_BEGIN log_fn(LOG_ERR, LD_NET, "Error while %s: %s", act,         \
+              tor_socket_strerror(tor_socket_errno(_s))); STMT_END
+
+static void usage(void) ATTR_NORETURN;
+
+/** Set *<b>out</b> to a newly allocated SOCKS4/SOCKS4a/SOCKS5 connect
+ * <b>username</b> (not in SOCKS5) and <b>hostname</b> as provided.
+ * Return the number of bytes in the request. */
+static ssize_t
+build_socks_connect_request(char **out,
+                            const char *username,
+                            const char *hostname,
+			    const int port,
+                            int version)
+{
+  size_t len = 0, off = 0, ab_len = 0;
+  unsigned char ab[16];
+  struct in_addr iaddr;
+  struct in6_addr iaddr6;
+
+  tor_assert(out);
+  tor_assert(username);
+  tor_assert(hostname);
+
+  if (tor_inet_pton(AF_INET, hostname, &iaddr)) {
+    /* It's an IPv4 IP. */
+    ab_len = 4;
+    memcpy(ab, &(iaddr.s_addr), ab_len);
+  } else if (tor_inet_pton(AF_INET6, hostname, &iaddr6)) {
+    /* It's an IPv6 IP. */
+    ab_len = 16;
+    memcpy(ab, &(iaddr6.s6_addr), ab_len);
+  }
+
+  if (version == 4) {
+    len = 8 + strlen(username) + 1 + strlen(hostname) + 1;
+    *out = tor_malloc(len);
+    *((*out)+off) = 4; /* SOCKS version 4 */
+    off++;
+    *((*out)+off) = 1; /* Command: connect */
+    off++;
+    set_uint16((*out)+off, htons(port)); /* port */
+    off+=2;
+    switch (ab_len) {
+    case 0:
+      set_uint32((*out)+off, htonl(0x00000001u)); /* addr: 0.0.0.1 */
+      off+=4;
+      break;
+    case 4:
+      memcpy((*out)+off, ab, 4); /* addr */
+      off+=4;
+      break;
+    case 16:
+      log_err(LD_GENERAL, "Tried to connect to IPv6 address using SOCKS4!");
+      return -1;
+    default:
+      tor_assert(0);
+    }
+    memcpy((*out)+off, username, strlen(username)+1);
+    off+=strlen(username)+1;
+    if (ab_len == 0) {
+      memcpy((*out)+off, hostname, strlen(hostname)+1);
+      off+=strlen(hostname)+1;
+    }
+  } else if (version == 5) {
+    len = 6 + ab_len;
+    if (ab_len == 0) {
+      len += strlen(hostname) + 1;
+    }
+    *out = tor_malloc(len);
+    *((*out)+off) = 5; /* SOCKS version 4 */
+    off++;
+    *((*out)+off) = 1; /* Command: connect */
+    off++;
+    *((*out)+off) = 0; /* reserved */
+    off++;
+    switch (ab_len) {
+    case 0:
+      *((*out)+off) = 3; /* domainname */
+      off++;
+      *((*out)+off) = strlen(hostname);
+      off++;
+      memcpy((*out)+off, hostname, strlen(hostname)); /* addr */
+      off+=strlen(hostname);
+      break;
+    case 4:
+      *((*out)+off) = 1; /* ipv4 */
+      off++;
+      memcpy((*out)+off, ab, 4); /* addr */
+      off+=4;
+      break;
+    case 16:
+      *((*out)+off) = 4; /* ipv6 */
+      off++;
+      memcpy((*out)+off, ab, 16); /* addr */
+      off+=16;
+      break;
+    default:
+      tor_assert(0);
+    }
+    set_uint16((*out)+off, htons(port)); /* port */
+    off+=2;
+  }
+  tor_assert(off==len);
+
+  return len;
+}
+
+/* It would be nice to let someone know what SOCKS4 issue a user may have,
+    but SOCKS4 error codes are beyond useless. */
+static const char *
+socks4_reason_to_string(char reason)
+{
+  switch (reason) {
+  case 0x5a:
+    return "succeeded";
+  case 0x5b:
+    return "request denied or failed";
+  case 0x5c:
+    return "client ident daemon unreachable";
+  case 0x5d:
+    return "client ident verification failed";
+  default:
+    return "unknown SOCKS4/SOCKS4a code";
+  }
+}
+/* It would be nice to let someone know what SOCKS5 issue a user may have */
+static const char *
+socks5_reason_to_string(char reason)
+{
+  switch (reason) {
+    case SOCKS5_SUCCEEDED:
+      return "succeeded";
+    case SOCKS5_GENERAL_ERROR:
+      return "general error";
+    case SOCKS5_NOT_ALLOWED:
+      return "not allowed";
+    case SOCKS5_NET_UNREACHABLE:
+      return "network is unreachable";
+    case SOCKS5_HOST_UNREACHABLE:
+      return "host is unreachable";
+    case SOCKS5_CONNECTION_REFUSED:
+      return "connection refused";
+    case SOCKS5_TTL_EXPIRED:
+      return "ttl expired";
+    case SOCKS5_COMMAND_NOT_SUPPORTED:
+      return "command not supported";
+    case SOCKS5_ADDRESS_TYPE_NOT_SUPPORTED:
+      return "address type not supported";
+    default:
+      return "unknown SOCKS5 code";
+  }
+}
+
+/** Send a connect request for <b>hostname</b> to the Tor listening on
+ * <b>sockshost</b>:<b>socksport</b>.  Return the resulting socket
+ * file descripto or -1 in case of error.
+ */
+static int
+do_connect(const char *hostname, uint16_t port,
+	   uint32_t sockshost, uint16_t socksport,
+	   int version)
+{
+  int s;
+  struct sockaddr_in socksaddr;
+  char *req = NULL, *tmp_buf = NULL;
+  ssize_t len = 0;
+
+  tor_assert(hostname);
+  tor_assert(version == 4 || version == 5);
+
+  s = tor_open_socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
+  if (s<0) {
+    log_sock_error("creating_socket", -1);
+    return -1;
+  }
+  memset(&socksaddr, 0, sizeof(socksaddr));
+  socksaddr.sin_family = AF_INET;
+  socksaddr.sin_port = htons(socksport);
+  socksaddr.sin_addr.s_addr = htonl(sockshost);
+  if (connect(s, (struct sockaddr*)&socksaddr, sizeof(socksaddr))) {
+    log_sock_error("connecting to SOCKS host", s);
+    close(s);
+    return -1;
+  }
+
+  if (version == 5) {
+    char method_buf[2];
+    if (write_all(s, "\x05\x01\x00", 3, 1) != 3) {
+      log_err(LD_NET, "Error sending SOCKS5 method list.");
+      close(s);
+      return -1;
+    }
+    if (read_all(s, method_buf, 2, 1) != 2) {
+      log_err(LD_NET, "Error reading SOCKS5 methods.");
+      close(s);
+      return -1;
+    }
+    if (method_buf[0] != '\x05') {
+      log_err(LD_NET, "Unrecognized socks version: %u",
+              (unsigned)method_buf[0]);
+      close(s);
+      return -1;
+    }
+    if (method_buf[1] != '\x00') {
+      log_err(LD_NET, "Unrecognized socks authentication method: %u",
+              (unsigned)method_buf[1]);
+      close(s);
+      return -1;
+    }
+  }
+
+  if ((len = build_socks_connect_request(&req, "", hostname, port,
+					 version))<0) {
+    log_err(LD_BUG,"Error generating SOCKS request");
+    tor_assert(!req);
+    close(s);
+    return -1;
+  }
+
+  if (write_all(s, req, len, 1) != len) {
+    log_sock_error("sending SOCKS request", s);
+    tor_free(req);
+    close(s);
+    return -1;
+  }
+  tor_free(req);
+
+  if (version == 4) {
+    char reply_buf[RESPONSE_LEN_4];
+    if (read_all(s, reply_buf, RESPONSE_LEN_4, 1) != RESPONSE_LEN_4) {
+      log_err(LD_NET, "Error reading SOCKS4 response.");
+      close(s);
+      return -1;
+    }
+    if (reply_buf[1] != 0x5a) {
+      log_warn(LD_NET,"Got SOCKS4 status response '%u': %s",
+               (unsigned)reply_buf[1],
+               socks4_reason_to_string(reply_buf[1]));
+      close(s);
+      return -1;
+    }
+  } else {
+    char reply_buf[4];
+    if (read_all(s, reply_buf, 4, 1) != 4) {
+      log_err(LD_NET, "Error reading SOCKS5 response.");
+      close(s);
+      return -1;
+    }
+    if (reply_buf[0] != 5) {
+      log_err(LD_NET, "Bad SOCKS5 reply version.");
+      close(s);
+      return -1;
+    }
+    /* Give a user some useful feedback about SOCKS5 errors */
+    if (reply_buf[1] != 0) {
+      log_warn(LD_NET,"Got SOCKS5 status response '%u': %s",
+               (unsigned)reply_buf[1],
+               socks5_reason_to_string(reply_buf[1]));
+      close(s);
+      return -1;
+    }
+    switch (reply_buf[3]) {
+    case 1:
+      tmp_buf = tor_malloc(4);
+      if (read_all(s, tmp_buf, 4, 1) != 4) {
+        log_err(LD_NET, "Error reading IPv4 address in socks5 response.");
+	close(s);
+        return -1;
+      }
+      tor_free(tmp_buf);
+      break;
+    case 3:
+      if (read_all(s, reply_buf, 1, 1) != 1) {
+        log_err(LD_NET, "Error reading domain name length in socks5 response.");
+	close(s);
+        return -1;
+      }
+      if (reply_buf[0] < 1) {
+        log_err(LD_NET, "Invalid reading domain name length in socks5 response.");
+	close(s);
+        return -1;
+      }
+      tmp_buf = tor_malloc(reply_buf[0]);
+      if (read_all(s, tmp_buf, 4, 1) != reply_buf[0]) {
+        log_err(LD_NET, "Error reading domain name in socks5 response.");
+	close(s);
+        return -1;
+      }
+      tor_free(tmp_buf);
+      break;
+    case 4:
+      tmp_buf = tor_malloc(16);
+      if (read_all(s, tmp_buf, 16, 1) != 16) {
+        log_err(LD_NET, "Error reading IPv6 address in socks5 response.");
+	close(s);
+        return -1;
+      }
+      tor_free(tmp_buf);
+      break;
+    default:
+      log_err(LD_NET, "Invalid address type in socks5 response.");
+      close(s);
+      return -1;
+    }
+    if (read_all(s, reply_buf, 2, 1) != 2) {
+      log_err(LD_NET, "Error reading port number socks5 response.");
+      close(s);
+      return -1;
+    }
+  }
+  return s;
+}
+
+static int
+nonblock_fd(int fd)
+{
+  int arg;
+
+  if ((arg = fcntl(fd, F_GETFL, 0)) < 0)
+    return 0;
+  if (arg & O_NONBLOCK)
+    return 1;
+  if (fcntl(fd, F_SETFL, arg | O_NONBLOCK) < 0)
+    return 0;
+  return 1;
+}
+
+
+/** Relay 2-way traffic between a socket and stdin/stdout.
+ */
+#define RELAY_BUF_LEN 2048
+static void
+do_stdio_relay(int s)
+{
+  fd_set rdset;
+  fd_set wrset;
+  char *in_buf, *out_buf;
+  size_t in_len=0, out_len=0;
+  int remote_closed=0, local_closed=0, lin, lout, maxfd;
+  int lin_blocked=0, lout_blocked=0, sin_blocked=0, sout_blocked=0;
+  ssize_t rv;
+
+  lin = fileno(stdin);
+  lout = fileno(stdout);
+  if (! (nonblock_fd(lin) && nonblock_fd(lout) && nonblock_fd(s))) {
+      log_err(LD_NET, "Unable to set streams to non-blocking mode.");
+      return;
+  }
+  in_buf = tor_malloc(RELAY_BUF_LEN);
+  out_buf = tor_malloc(RELAY_BUF_LEN);
+  maxfd = 0;
+  if (lin > maxfd)
+    maxfd = lin;
+  if (lout > maxfd)
+    maxfd = lout;
+  if (s > maxfd)
+    maxfd = s;
+
+  while (! (remote_closed && (in_len==0))) {
+    FD_ZERO(&rdset);
+    FD_ZERO(&wrset);
+    if (((!remote_closed) && (!sin_blocked) && (in_len<RELAY_BUF_LEN)) ||
+	((!local_closed) && (!lin_blocked) && (out_len<RELAY_BUF_LEN)) ||
+	((!sout_blocked) && (out_len>0)) ||
+	((!lout_blocked) && (in_len>0))) {
+      if ((!remote_closed) && (!sin_blocked) && (in_len<RELAY_BUF_LEN)) {
+	FD_SET(s, &rdset);
+      }
+      if ((!local_closed) && (!lin_blocked) && (out_len<RELAY_BUF_LEN)) {
+	FD_SET(lin, &rdset);
+      }
+      if ((!sout_blocked) && (out_len>0)) {
+	FD_SET(s, &wrset);
+      }
+      if ((!lout_blocked) && (in_len>0)) {
+	FD_SET(lout, &wrset);
+      }
+    } else {
+      if ((!local_closed) && (out_len<RELAY_BUF_LEN)) {
+	FD_SET(lin, &rdset);
+      }
+      if ((!remote_closed) && (in_len<RELAY_BUF_LEN)) {
+	FD_SET(s, &rdset);
+      }
+      if (in_len>0) {
+	FD_SET(lout, &wrset);
+      }
+      if ((!remote_closed) && (out_len>0)) {
+	FD_SET(s, &wrset);
+      }
+      rv = select(maxfd + 1, &rdset, &wrset, NULL, NULL);
+      if (rv < 0) {
+	log_err(LD_NET, "Call to select() failed.");
+	return;
+      }
+    }
+    if (FD_ISSET(s, &wrset)) {
+      sout_blocked = 0;
+      rv = write(s, out_buf, out_len);
+      if (rv < 0) {
+	if ((errno == EWOULDBLOCK) || (errno == EAGAIN)) {
+	  sout_blocked = 1;
+	} else {
+	  return;
+	}
+      } 
+      if (rv > 0) {
+	if (rv < out_len) {
+	  memmove(out_buf, out_buf+rv, out_len-rv);
+	}
+	out_len -= rv;
+      }
+    }
+    if (FD_ISSET(lout, &wrset)) {
+      lout_blocked = 0;
+      rv = write(lout, in_buf, in_len);
+      if (rv < 0) {
+	if ((errno == EWOULDBLOCK) || (errno == EAGAIN)) {
+	  lout_blocked = 1;
+	} else {
+	  return;
+	}
+      }
+      if (rv > 0) {
+	if (rv < in_len) {
+	  memmove(in_buf, in_buf+rv, in_len-rv);
+	}
+	in_len -= rv;
+      }
+    }
+    if (FD_ISSET(s, &rdset)) {
+      sin_blocked = 0;
+      rv = read(s, in_buf+in_len, RELAY_BUF_LEN-in_len);
+      if (rv < 0) {
+	if ((errno == EWOULDBLOCK) || (errno == EAGAIN)) {
+	  sin_blocked = 1;
+	} else {
+	  return;
+	}
+      }
+      if (rv == 0) {
+	close(s);
+	close(lout);
+	remote_closed = 1;
+      }
+      if (rv > 0) {
+	in_len += rv;
+      }
+    }
+    if (FD_ISSET(lin, &rdset)) {
+      lin_blocked = 0;
+      rv = read(lin, out_buf+out_len, RELAY_BUF_LEN-out_len);
+      if (rv < 0) {
+	if ((errno == EWOULDBLOCK) || (errno == EAGAIN)) {
+	  lin_blocked = 1;
+	} else {
+	  return;
+	}
+      }
+      if (rv == 0) {
+	close(lin);
+	shutdown(s, SHUT_WR);
+	local_closed = 1;
+      }
+      if (rv > 0) {
+	out_len += rv;
+      }
+    }
+  }
+}
+
+/** Print a usage message and exit. */
+static void
+usage(void)
+{
+  puts("Syntax: tor-connect [-4 | -5] [-v] "
+       "hostname port [sockshost:socksport]");
+  exit(1);
+}
+
+/** Entry point to tor-connect */
+int
+main(int argc, char **argv)
+{
+  uint32_t sockshost;
+  uint16_t port = 0, socksport = 0, port_option = 0;
+  int isSocks4 = 0, isVerbose = 0;
+  char **arg;
+  int n_args, sock;
+  log_severity_list_t *s = tor_malloc_zero(sizeof(log_severity_list_t));
+
+  init_logging();
+
+  arg = &argv[1];
+  n_args = argc-1;
+
+  if (!n_args)
+    usage();
+
+  if (!strcmp(arg[0],"--version")) {
+    printf("Tor version %s.\n",VERSION);
+    return 0;
+  }
+  while (n_args && *arg[0] == '-') {
+    if (!strcmp("-v", arg[0]))
+      isVerbose = 1;
+    else if (!strcmp("-4", arg[0]))
+      isSocks4 = 1;
+    else if (!strcmp("-5", arg[0]))
+      isSocks4 = 0;
+    else if (!strcmp("-p", arg[0])) {
+      int p;
+      if (n_args < 2) {
+        fprintf(stderr, "No arguments given to -p\n");
+        usage();
+      }
+      p = atoi(arg[1]);
+      if (p<1 || p > 65535) {
+        fprintf(stderr, "-p requires a number between 1 and 65535\n");
+        usage();
+      }
+      port_option = (uint16_t) p;
+      ++arg; /* skip the port */
+      --n_args;
+    } else {
+      fprintf(stderr, "Unrecognized flag '%s'\n", arg[0]);
+      usage();
+    }
+    ++arg;
+    --n_args;
+  }
+
+  if (isVerbose)
+    set_log_severity_config(LOG_DEBUG, LOG_ERR, s);
+  else
+    set_log_severity_config(LOG_WARN, LOG_ERR, s);
+  add_stream_log(s, "<stderr>", fileno(stderr));
+
+  if (n_args == 2) {
+    log_debug(LD_CONFIG, "defaulting to localhost");
+    sockshost = 0x7f000001u; /* localhost */
+    if (port_option) {
+      log_debug(LD_CONFIG, "Using port %d", (int)port_option);
+      socksport = port_option;
+    } else {
+      log_debug(LD_CONFIG, "defaulting to port 9050");
+      socksport = 9050; /* 9050 */
+    }
+  } else if (n_args == 3) {
+    if (addr_port_lookup(LOG_WARN, arg[2], NULL, &sockshost, &socksport)<0) {
+      fprintf(stderr, "Couldn't parse/resolve address %s", arg[2]);
+      return 1;
+    }
+    if (socksport && port_option && socksport != port_option) {
+      log_warn(LD_CONFIG, "Conflicting ports; using %d, not %d",
+               (int)socksport, (int)port_option);
+    } else if (port_option) {
+      socksport = port_option;
+    } else if (!socksport) {
+      log_debug(LD_CONFIG, "defaulting to port 9050");
+      socksport = 9050;
+    }
+  } else {
+    usage();
+  }
+
+  {
+    int p;
+    p = atoi(arg[1]);
+    if (p<1 || p > 65535) {
+      fprintf(stderr, "Port number must be between 1 and 65535\n");
+      usage();
+    }
+    port = p;
+  }
+
+  if (network_init()<0) {
+    log_err(LD_BUG,"Error initializing network; exiting.");
+    return 1;
+  }
+
+  if ((sock = do_connect(arg[0], port, sockshost, socksport, isSocks4 ? 4 : 5)) < 0) {
+    fprintf(stderr, "Unable to open connection.\n");
+    return 1;
+  }
+  do_stdio_relay(sock);
+  return 0;
+}
+
